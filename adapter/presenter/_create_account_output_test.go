// ********RoostGPT********
/*
Test generated by RoostGPT for test mayankzbio-go-clean using AI Type Claude AI and AI Model claude-3-5-sonnet-20240620

ROOST_METHOD_HASH=Output_176178cc60
ROOST_METHOD_SIG_HASH=Output_d83d35060a

FUNCTION_DEF=func (a createAccountPresenter) Output(account domain.Account) usecase.CreateAccountOutput
Based on the provided function and context, here are several test scenarios for the `Output` method of the `createAccountPresenter` struct:

```
Scenario 1: Successful Account Output Conversion

Details:
  Description: This test verifies that the Output method correctly converts a domain.Account object to a usecase.CreateAccountOutput object with all fields properly mapped.

Execution:
  Arrange:
    - Create a mock domain.Account with known values for all fields.
    - Initialize a createAccountPresenter instance.
  Act:
    - Call the Output method with the mock account.
  Assert:
    - Verify that the returned usecase.CreateAccountOutput matches the expected values from the input account.

Validation:
  This test ensures that the presenter correctly translates internal domain objects to the expected output format. It's crucial for maintaining the contract between the use case and the external interfaces of the application.

Scenario 2: Zero Balance Account Output

Details:
  Description: Test the Output method's handling of an account with a zero balance to ensure proper formatting.

Execution:
  Arrange:
    - Create a mock domain.Account with a balance of 0.
    - Initialize a createAccountPresenter instance.
  Act:
    - Call the Output method with the zero-balance account.
  Assert:
    - Verify that the Balance field in the output is exactly 0.0 (not a small floating-point value).

Validation:
  This test checks the precision of balance representation, which is important for financial applications where exact zero balances may have significance.

Scenario 3: Maximum Value Handling

Details:
  Description: Verify that the Output method correctly handles an account with maximum possible values for its numeric fields.

Execution:
  Arrange:
    - Create a mock domain.Account with the maximum possible balance value.
    - Initialize a createAccountPresenter instance.
  Act:
    - Call the Output method with the maximum-value account.
  Assert:
    - Check that the Balance field in the output correctly represents the maximum value without loss of precision.

Validation:
  This edge case test ensures that the presenter can handle extreme values without overflow or loss of precision, which is critical for maintaining data integrity.

Scenario 4: Proper Time Formatting

Details:
  Description: Ensure that the CreatedAt field is correctly formatted according to RFC3339 standard.

Execution:
  Arrange:
    - Create a mock domain.Account with a known creation time.
    - Initialize a createAccountPresenter instance.
  Act:
    - Call the Output method with the account.
  Assert:
    - Verify that the CreatedAt field in the output is a string formatted exactly as per RFC3339.

Validation:
  Consistent time formatting is crucial for interoperability and data consistency across different parts of the system or external integrations.

Scenario 5: ID String Conversion

Details:
  Description: Test that the account ID is correctly converted to a string representation.

Execution:
  Arrange:
    - Create a mock domain.Account with a known ID value.
    - Initialize a createAccountPresenter instance.
  Act:
    - Call the Output method with the account.
  Assert:
    - Check that the ID field in the output is a string and matches the expected string representation of the account's ID.

Validation:
  Proper ID conversion ensures that the unique identifier of the account is preserved and correctly represented in the output format.

Scenario 6: Empty String Handling

Details:
  Description: Verify that the Output method correctly handles an account with empty string values for name and CPF.

Execution:
  Arrange:
    - Create a mock domain.Account with empty strings for Name and CPF.
    - Initialize a createAccountPresenter instance.
  Act:
    - Call the Output method with the account containing empty strings.
  Assert:
    - Confirm that the Name and CPF fields in the output are empty strings, not null or undefined.

Validation:
  This test ensures that the presenter maintains data integrity even when dealing with empty input, which is important for consistent data handling and avoiding null pointer exceptions in consuming code.
```

These scenarios cover a range of normal operations, edge cases, and potential issues that could arise when using the `Output` method of the `createAccountPresenter`. They focus on data integrity, proper type conversion, formatting, and handling of various input conditions.
*/

// ********RoostGPT********
package presenter

import (
	"testing"
	"time"

	"github.com/gsabadini/go-clean-architecture/domain"
	"github.com/gsabadini/go-clean-architecture/usecase"
)

func TestcreateAccountPresenterOutput(t *testing.T) {
	tests := []struct {
		name     string
		input    domain.Account
		expected usecase.CreateAccountOutput
	}{
		{
			name: "Successful Account Output Conversion",
			input: domain.Account{
				id:        "123",
				name:      "John Doe",
				cpf:       "12345678901",
				balance:   1000.50,
				createdAt: time.Date(2023, 5, 1, 10, 30, 0, 0, time.UTC),
			},
			expected: usecase.CreateAccountOutput{
				ID:        "123",
				Name:      "John Doe",
				CPF:       "12345678901",
				Balance:   1000.50,
				CreatedAt: "2023-05-01T10:30:00Z",
			},
		},
		{
			name: "Zero Balance Account Output",
			input: domain.Account{
				id:        "456",
				name:      "Jane Smith",
				cpf:       "98765432109",
				balance:   0.0,
				createdAt: time.Date(2023, 5, 2, 14, 45, 0, 0, time.UTC),
			},
			expected: usecase.CreateAccountOutput{
				ID:        "456",
				Name:      "Jane Smith",
				CPF:       "98765432109",
				Balance:   0.0,
				CreatedAt: "2023-05-02T14:45:00Z",
			},
		},
		{
			name: "Maximum Value Handling",
			input: domain.Account{
				id:        "789",
				name:      "Max Balance",
				cpf:       "11122233344",
				balance:   1e18, // Example of a very large balance
				createdAt: time.Date(2023, 5, 3, 9, 0, 0, 0, time.UTC),
			},
			expected: usecase.CreateAccountOutput{
				ID:        "789",
				Name:      "Max Balance",
				CPF:       "11122233344",
				Balance:   1e18,
				CreatedAt: "2023-05-03T09:00:00Z",
			},
		},
		{
			name: "Empty String Handling",
			input: domain.Account{
				id:        "101",
				name:      "",
				cpf:       "",
				balance:   100.0,
				createdAt: time.Date(2023, 5, 4, 12, 15, 0, 0, time.UTC),
			},
			expected: usecase.CreateAccountOutput{
				ID:        "101",
				Name:      "",
				CPF:       "",
				Balance:   100.0,
				CreatedAt: "2023-05-04T12:15:00Z",
			},
		},
	}

	presenter := createAccountPresenter{}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := presenter.Output(tt.input)

			if result.ID != tt.expected.ID {
				t.Errorf("ID mismatch. Got %s, want %s", result.ID, tt.expected.ID)
			}
			if result.Name != tt.expected.Name {
				t.Errorf("Name mismatch. Got %s, want %s", result.Name, tt.expected.Name)
			}
			if result.CPF != tt.expected.CPF {
				t.Errorf("CPF mismatch. Got %s, want %s", result.CPF, tt.expected.CPF)
			}
			if result.Balance != tt.expected.Balance {
				t.Errorf("Balance mismatch. Got %f, want %f", result.Balance, tt.expected.Balance)
			}
			if result.CreatedAt != tt.expected.CreatedAt {
				t.Errorf("CreatedAt mismatch. Got %s, want %s", result.CreatedAt, tt.expected.CreatedAt)
			}
		})
	}
}
